### Item59 了解和使用类库

> Suppose you want to generate random integers between zero and some upper bound. Faced with this common task, many programmers would write a little method that looks something like this:

假如你想生成一个0到某个上限值之间的随机Integer。面对这个普通的任务，很多程序员都可能会写一个下面这样的小方法：

```java
// Common but deeply flawed!
   static Random rnd = new Random();
   static int random(int n) {
       return Math.abs(rnd.nextInt()) % n;
}
```

> This method may look good, but it has three flaws. The first is that if n is a small power of two, the sequence of random numbers will repeat itself after a fairly short period. The second flaw is that if n is not a power of two, some numbers will, on average, be returned more frequently than others. If n is large, this effect can be quite pronounced. This is powerfully demonstrated by the following program, which generates a million random numbers in a carefully chosen range and then prints out how many of the numbers fell in the lower half of the range:

这个方法可能看起来还好，但是有三个缺点。第一个缺点是如果这个n是比较小的2的乘方，生成的随机数序列在很短的一段后，就会是重复的。第二个缺点是如果这个不是2的乘方，那么有一些值就会就会出现的次数就要比其他的值多一些。如果n很大的话，这个效果就更加明显。下面这个程序就可以强有力地证明这个结果，这个程序在一个选定的区域内，生成了1百万个随机数，并且打印了落在随机区域前半部分的随机数的数量。程序如下：

```java
public static void main(String[] args) {
       int n = 2 * (Integer.MAX_VALUE / 3);
       int low = 0;
       for (int i = 0; i < 1000000; i++)
           if (random(n) < n/2)
               low++;
       System.out.println(low);
}
```

> If the random method worked properly, the program would print a number close to half a million, but if you run it, you’ll find that it prints a number close to 666,666. Two-thirds of the numbers generated by the random method fall in the lower half of its range!

如果这个random方法正常工作的话，这个程序打印的数值应该接近1百万的一半，但是如果你运行它的话，你就会发现打印的结果接近666,666，这个random方法生成的随机数3分之2都落在了随机区域的前半部分！

> The third flaw in the random method is that it can, on rare occasions, fail catastrophically, returning a number outside the specified range. This is so because the method attempts to map the value returned by rnd.nextInt() to a non-negative int by calling Math.abs. If nextInt() returns Integer.MIN_VALUE, Math.abs will also return Integer.MIN_VALUE, and the remainder operator (%) will return a negative number, assuming n is not a power of two. This will almost certainly cause your program to fail, and the failure may be difficult to reproduce.

这个random方法的第三个缺点是，在极少数的情况下，这个方法可能出现灾难性的失败，返回一个在指定区域外的数字。这是因为这个方法会将rnd.nextInt返回的值通过Math.abs方法转换为一个非负数。如果nextInt() 返回的是Integer.MIN_VALUE，那么Math.abs 也会返回Integer.MIN_VALUE，然后，如果n不是2的乘方的话，通过取余操作（%）就会返回一个负数。这几乎会导致程序失败，而且这个错误很难复现。

> To write a version of the random method that corrects these flaws, you’d have to know a fair amount about pseudorandom number generators, number theory, and two’s complement arithmetic. Luckily, you don’t have to do this—it’s been done for you. It’s called Random.nextInt(int). You needn’t concern yourself with the details of how it does its job (although you can study the documentation or the source code if you’re curious). A senior engineer with a background in algorithms spent a good deal of time designing, implementing, and testing this method and then showed it to several experts in the field to make sure it was right. Then the library was beta tested, released, and used extensively by millions of programmers for almost two decades. No flaws have yet been found in the method, but if a flaw were to be discovered, it would be fixed in the next release. **By using a standard library, you take advantage of the knowledge of the experts who wrote it and the experience of those who used it before you.**

为了编写一个没有这些缺点的随机方法，你必须要知道很多关于伪随机数生成器，数论、2的求补算法相关的知识。幸运地是，你并不需要了解这么多——已经有人为了做好了。这个方法是 Random.nextInt(int).。你不用关系你这个方法是怎么做到的（如果你好气的话，你也可以看文档或者源代码来了解）。一个拥有很好的算法背景的高级工程师花了很长的时间来设计实现测试，并且展示给这个领域的其他专家以确定这是正确的。然后类库也进行了Bata测试，发版，在这20年间，已经有很多的人使用这个方法。至今还没有发现什么缺点，就算以后发现了缺点，它也会在后面的版本中修复的。**通过使用标准类库，可以充分利用编写类库的专家的只是，以及在你之前使用他们的程序员的经验。**

> As of Java 7, you should no longer use Random. For most uses, **the random number generator of choice is now** **ThreadLocalRandom.** It produces higher quality random numbers, and it’s very fast. On my machine, it is 3.6 times faster than Random. For fork join pools and parallel streams, use SplittableRandom.

在Java7以后，你就不应该使用Random了。**现在在选择随机数生成器的时候大部分时候都选择ThreadLocalRandom**。它会生成质量更好的随机数，而且速度还快。在我的机器上，它的速度比Random快了3.6倍。对于fork join pool和并行stream，应该使用SplittableRandom。

> A second advantage of using the libraries is that you don’t have to waste your time writing ad hoc solutions to problems that are only marginally related to your work. If you are like most programmers, you’d rather spend your time working on your application than on the underlying plumbing.

使用标准类库的第二个优点是，你不需要浪费时间来为一个和工作关系不大的问题编写特别的解决方法。你应该和大部分程序员一样，把你的时间花在应用程序上，而不是底层实现。

> A third advantage of using standard libraries is that their performance tends to improve over time, with no effort on your part. Because many people use them and because they’re used in industry-standard benchmarks, the organizations that supply these libraries have a strong incentive to make them run faster. Many of the Java platform libraries have been rewritten over the years, sometimes repeatedly, resulting in dramatic performance improvements.

使用标准类库的第三个优点是，随着时间推进，在不需要你任何努力的情况下，这些方法的性能也会越来越好。因为很多人都使用这些方法，并且他们还是在工业标准环境下使用的。因此发布这个类库的机构就有强烈的动机来让这些方法运行得更快。这些年来，很多的Java平台类库都进行了重新编写，有时候重复进行，使得其性能得到了显著的提高。

> A fourth advantage of using libraries is that they tend to gain functionality over time. If a library is missing something, the developer community will make it known, and the missing functionality may get added in a subsequent release.

使用标准类库的第四个优点是，随着时间推进，他们会新增一些功能。如果一个类库缺少了一些功能，开发者社区就会让他们知道，然后缺少的功能就会再后面的版本中添加进去。

> A final advantage of using the standard libraries is that you place your code in the mainstream. Such code is more easily readable, maintainable, and reusable by the multitude of developers.

使用标准类库的最后一个优点是，你的代码可以融入主流。使用标准类库的代码更容易阅读，好维护，也可以被其他的开发者重用。

> Given all these advantages, it seems only logical to use library facilities in preference to ad hoc implementations, yet many programmers don’t. Why not? Perhaps they don’t know the library facilities exist. **Numerous features are added to the libraries in every major release, and it pays to keep abreast of these additions.** Each time there is a major release of the Java platform, a web page is published describing its new features. These pages are well worth reading [Java8-feat, Java9-feat]. To reinforce this point, suppose you wanted to write a program to print the contents of a URL specified on the command line (which is roughly what the Linux curl command does). Prior to Java 9, this code was a bit tedious, but in Java 9 the transferTo method was added to InputStream. Here is a complete program to perform this task using this new method:

既然有这么多的优点，看起来相对于自己实现，优先选择使用类库机制是非常合理的，但是还是有很多程序员没有这么做，这是为什么呢？大概是他们不知道类库里有这些机制。**在每一次重要的版本发行中，有会增加超级多的新的特征，要和这些新的功能齐头并进，是需要花很多功夫的**。Java平台每次发布一个重要的版本，都会有一个网页来描述它的新的特征。这些网页很值得阅读[Java8-feat, Java9-feat]。为了重申这一点，假如你想写一个程序，来打印命令行中指定的URL的内容（大概就是Linux命令curl做的事情）。在Java9之前，这个代码可能会有点繁琐。但是在Java9中，在InputStream里增加了一个transferTo方法，下面是使用transferTo方法实现这个任务的全部代码：

```java
// Printing the contents of a URL with transferTo, added in Java 9
   public static void main(String[] args) throws IOException {
       try (InputStream in = new URL(args[0]).openStream()) {
			 in.transferTo(System.out); }
}
```

> The libraries are too big to study all the documentation [Java9-api], but **every programmer should be familiar with the basics of** **java.lang**, **java.util, and java.io, and their subpackages.** Knowledge of other libraries can be acquired on an as-needed basis. It is beyond the scope of this item to summarize the facilities in the libraries, which have grown immense over the years.

这些标准类库已经太大了，以至于我们无法学习所有的文档 [Java9-api]，但是**每一个程序员都都应该对基本的java.lang, java.util, 和java.io, 以及其子包的内容非常熟悉。**其他类库的知识，可以在需要的时候进行学习。对类库的机制进行总结超出了本节的范围，这些年它们已经发展得特别大了。

> Several libraries bear special mention. The collections framework and the streams library (Items 45–48) should be part of every programmer’s basic toolkit, as should parts of the concurrency utilities in java.util.concurrent. This package contains both high-level utilities to simplify the task of multithreaded programming and low-level primitives to allow experts to write their own higher- level concurrent abstractions. The high-level parts of java.util.concurrent are discussed in Items 80 and 81.

有一些类库需要特别的关注。集合框架和Stream类库(Items 45–48) 和java.util.concurrent里的并发机制应该是每一个程序员的基本工具。java.util.concurrent包里包含用来简化多线程任务编程的高级的工具，还包括一些低级别的并发基本类型以允许一些专家编写自己的高级的并发抽象。java.util.concurrent中的高级部分会在Item80和81里讨论。

> Occasionally, a library facility can fail to meet your needs. The more specialized your needs, the more likely this is to happen. While your first impulse should be to use the libraries, if you’ve looked at what they have to offer in some area and it doesn’t meet your needs, then use an alternate implementation. There will always be holes in the functionality provided by any finite set of libraries. If you can’t find what you need in Java platform libraries, your next choice should be to look in high-quality third-party libraries, such as Google’s excellent, open source Guava library [Guava]. If you can’t find the functionality that you need in any appropriate library, you may have no choice but to implement it yourself.

有些时候，类库机制可能并不能满足你的需求。你的需求越特殊，这种情况发生得就越多。虽然你的第一直觉还是应该使用类库，当你方法它们咋一些领域提供的需求无法满足你的视乎，你就应该选择其他的实现。任何一组类库都提供的功能都可能有一些缺陷。如果你在Java类库中无法找到满足你需求的方法，你的第二个选择就应该是在高质量的第三方类库里寻找，比如Google的优秀的开源Guava类库。如果你发现你需要的功能在所有很是的类库中都找不到，那么你就必须要自己实现了。

> To summarize, don’t reinvent the wheel. If you need to do something that seems like it should be reasonably common, there may already be a facility in the libraries that does what you want. If there is, use it; if you don’t know, check. Generally speaking, library code is likely to be better than code that you’d write yourself and is likely to improve over time. This is no reflection on your abilities as a programmer. Economies of scale dictate that library code receives far more attention than most developers could afford to devote to the same functionality.

总结一下，不要重复造轮子。如果你需要做一些看起来很常见的事情，那么就可能在类库里已经存在你想要的机制了。如果有的话，就直接用；如果不知道的话，就去确定一下。总的来说，类库代码一般要比你自己写的代码好一些，而且随着时间推移，类库的代码还会进行优化。这并不是在质疑你作为一个程序员的能力。从经济的角度上来分析，类库代码受到的关注远远比大部分开发者在同样的功能上付出得多。
